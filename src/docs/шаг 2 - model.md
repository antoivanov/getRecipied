## Шаг 2.

### Создаём хранилище и модель.

**Начнём с хранилища** - создадим es6 класс Storage (или AppStorage, т.к. есть такой глобально доступный класс) который будет работать с неким объектом записывая или читая оттуда данные.

Нам потребуется конструктор с инициализирующей логилкй и два метода: set и get.

в конструктор можем передать имя нашего хранилища - строку.
Предположим, что с нашей памятью может рабоать несколько хранилищ (для каждого типа сущностей - своё), тогда создадим объект memoryStorage в файле хранилища, чтобы она не пересоздавалась конструктором AppStorage при создании новых экземпляров.

В конструкторе создаём поле экземпляра с именем (_dbname) и в случае отсутствия поля в memoryStorage с переданным name присваиваем полю с этим именем пустой объект.

В методах set и get есть особенность: 

* в memoryStorage мы записываем/читаем объекты через JSON.stringify/JSON.parse (защита от мутабельности);
* в set мы передаём ключ(key) и объект для записи по ключу. Т.е. получаем сначала нужную часть памяти (по name) далее в этой области по указанному ключу циклом сохраняем те поля, которые есть в переданном объекте для записи. Если key нет в памяти, то можно сохранить в это поле весь объект 
data[key] = updateData.



**Переходим к модели**

Создадим класс Model который унаследуется от AppStorage. 

Здесь следует подумать с чем мы в итоге будем работать.
В нашем приложении мы будем обращаться к [стороннему сервису рецептов](https://developer.edamam.com/edamam-docs-recipe-api-v1#:~:text=Greek%20Yogurt%20Dressing%E2%80%9D-,Example%20GET%20request,-Here%20is%20an), отправляя get запросы используя метод [fetch](https://learn.javascript.ru/fetch). Нам понадобиться как минимум сторка ввода запроса и кнопки для перелистывания страниц результата.

Также для отрисовки результатов контроллер будет передавать из модели сохранненные данные по рецептам.

```
К чему надо прийти:
* два метода для чтения и записи полей фильтра;
* два метода для чтения и записи полученных рецептов;
* метод инициализации модели (содержимое можно выполнить и в конструкторе, либо там просто вызвать this.init());
* асинхронный метод с запросом рецептов и сохранением в выделенный массив в памяти (вернёмся в 4 шаге).
```

Инициализирующая логика:
1. [По правилам JS](https://learn.javascript.ru/class-inheritance#pereopredelenie-konstruktora) в унаследованных классах перед работой с this необходимо вызвать конструктор родительского класса;
2. Далее в нашей памяти создаем две области filters и recipes, для чего используем метод set родителя (filters - будет объектом, а вот в массив recipes будут складываться объекты рецептов).
С инициализацией модели пока всё.

Два метода обёртки для работы со значением поискового запроса и постраничной выборкой (пагинацией):
создаём методы в которых используем метод родителя get и set, при этом в методе записи используем деструктуризацию для обновления старых полей объекта filters и добавления новых.

Два метода-обёртки для работы с рецептами:
Тут мы просто перезаписываем массив значений новыми данными в записи или читаем по ключу recipes из хранилища.