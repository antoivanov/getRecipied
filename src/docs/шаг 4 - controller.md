## Шаг 4.

### Создаём контроллер и шину событий.

**Начнём с контроллера** - создаём класс Controller который будет управляють поведением вьюшек через привязку необходимых хендлеров (или обработчиков, или колбеков) и работать с моделью данных.

Исходя из вышесказанного нам потребуется ассоциировать модель, вью и контроллер.
Для этого в коструктор мы передаём экземпляры модели и вью, в поле экземпляра routes также присваиваем массив страниц проекта 'about', 'recipes', 'profile'.
`Сейчас можно вернуться на шаг 1 и раскоментировать код в файле app.js.`

В данном классе существуют следующие группы методов:
**Методы для привязки к UI-элементам**
- setView(section) - метод вызывается при нажатии одной из кнопок навигационного меню хедера, принимает строковый параметр одной из страниц. Запускаем метод render с нужным параметром.

В данном методе для работы кнопок браузера вперёд и назад также надо поменять state истории, для этого добаляем запись:
```
window.history.pushState({}, '', '/${'наша страница'}')
```
Также потребуется разместить здесь инициализирующий метод для страницы рецептов.

_Далее идут методы, которые controller навешивает на UI элементы странцы рецептов._

-setSearch(query) - метод вызывается при вводе информации в input на странице recipes. В нём мы меняем соответствующее поле в модели и публикуем событие типа "полеПоискаИзменилось" используя метод publish экземпляра класса шины событий  (посмотрите [ролик](https://monsterlessons.com/project/lessons/publishsubscribe-v-javascript) и создайте в файле eventBus.js класс шины и экспортируйте оттуда экземпляр appEventBus).

-setRecipes() - синхронный метод, который вернёт из модели массив объектов с данными рецептов методу render c case-ом для рецепта. 

**Дополним шаг 3**, на текущий момент мы уже имеем представление о назначении модели, вью и контроллера, а также паттерна pub-sub.

Необходимо как-то запросить данные со стороннего ресурса, делать это мы будем в модели на событие, публикуемое в setSearch:

для этого в методе init модели добавляем подписку на событие из setSearch со след. колбеком:

```
() => this.названиеАсинхронногоМетодаМодели()
```

Указанный асинхронный метод должен сначала получить из модели значение запроса и страницы пагинации и передать это в метод экземпляра сервиса, который используется в модели через композицию (ничего не передаём, просто используем в методе).

Все асинхронные функции/методы должны предваряться записью async и строка в коде, которая непосредственно осуществляет асинхронную работу предваряется записью [await](https://learn.javascript.ru/async-await), в нашем случае это будет что-то вроде:

```
  async названиеАсинхронногоМетодаМодели() {
    // получаем страницу и запрос из модели
    const recipes = await имяСервиса.гетМетодСервиса(search, page)
    this.методЗаписиПолученныхРецептов(recipes)
    appEventBus.publish('рецептыЗагружены')
  }
```

Сервис для запросов рецептов совсем простой - там один метод для get-запросов, см. шаг 5.

_Возвращаемся к шагу 4..._

-onNextPage/onPrevPage - два метода, которые сначала смотрят есть ли какой-то текст в инпуте, потом какая текущая страница в модели и увеличивают или уменьшают это значение. Там же мы должны опубликовать событие "страницаПагинацииИзменилась" и попросить вьюшку отрендерить новое значение в отдельном блоке.


**Методы инициализации:**
- init() - тут мы должны смонтировать в тег body страницы root нашего вью, далее надо понять, где мы находимся при первоначальной загрузке приложения, для этого напишите служебный метод, который будет читать значение path url-а (желательно, чтобы пустое значение заменялось значением для главной страницы, у нас - about). После этого вызываем методы рендера хедера и страницы, далее добавляем через bindCallback колбек для отрисовки страницы:
```
(route) => this.setView(route)
```
Если в url есть path recipes - запускаем здесь инит метод для этой страницы.
Кроме того инициализируем filters в модели начальным значением поля поиска и страницы пагинации ('' и 0): в конструкторе мы присвоили модель в поле model и можем вызвать соответствующий метод setFilterValue.
_...позже дополним init работой с шиной событий..._

- initRecipes - здесь больше всего работы со вью (если бы логики и по recipes и по другим страницам было больше - то необходимо было выделять либо постранично, либо по бизнес сущностям отдельные MVC)
  У нас есть для вью три типа событий из switch-а bindCallback для которых controller имеет обработчики:
  "вводВИнпут" - setSearch
  "листаемВперёд"/"листаемНазад" - onNextPage/onPrevPage,
  кроме того при листании у нас пока только меняется цифра во вьюшке и надо отреагировать на событие "страницаПагинацииИзменилась" вызовом  setRecipes
  Также не забываем, что controller должен узнать, что в модели загрузились рецепты (вспоминаем про событие "рецептыЗагружены"), для чего мы подписываемся на это событие и передаём туда колбек:
  ```
  () => this.setRecipes()
  ```

Остаётся написать метод для отражения в query url-а страницы пагинации и запроса. 