## Шаг 5

### Создаём сервис для работы с API рецептов

Предварительно:
[1. Проходим регистрацию для получения appID и appKey;](https://developer.edamam.com/edamam-recipe-api)
[2. Знакомимся со структурой GET-запросов сервиса рецептов.](https://developer.edamam.com/edamam-docs-recipe-api-v1#:~:text=Greek%20Yogurt%20Dressing%E2%80%9D-,Example%20GET%20request,-Here%20is%20an)


На 4-ом шаге мы описали, что модель будет вызывать асинхронный метод сервиса при изменении value в инпуте (либо при листании). 

Сервисы предоставляют нам интерфейс взаимодействия с каким-то внешним ресурсом. Под интерфейсом понимается предоставляемый инструментарий, набор методов со своими сигнатурами, доступными/открытыми пользователю сервиса.

В конструктор класса сервиса необходимо будет передать appID и appKey, также сохранить в поле базовую часть URL-а сервиса - протокол и доменное имя, остальное будем менять в методе.

Метод принимает два параметра от модели - сам текст запроса и страницу. 
Для кода внутри асинхронных методов используется конструкция [try/catch/finally](https://learn.javascript.ru/try-catch), т.к. мы не можем контролировать наличие ответа сервиса и его структуру используют исключения, но это далеко не обязательно использовать в асинхронных функциях.

В нашем случае исключение будет выбрасываться, если [код статуса HTTP-запроса](https://developer.mozilla.org/ru/docs/Web/HTTP/Status) не будет в диапазоне 200-299 после выполнения fetch-запроса с нашим url-ом. Fetch API для удобства имеет специальное поле для этой проверки, соответственно если там не true - выбрасываем исключение, а в catch пришем:
```
catch (error) {
  console.error('Error fetching recipes:', error);
  return null;
}
```
Структура url-а для fetch запроса:
```
`${this.baseUrl}search?q=${request}&app_id=${this.appID}&app_key=${this.appKey}&from=${from}&to=${to}`;

```
Где from и to - с какого по какой рецепт хотим увидеть, для их вычисления и пригодится переданная страница. 

То, что получили в fetch ещё надо декодировать. Т.к. ответ сервиса приходит в формате json, следует воспользоваться соответствующим [методом для декодирования](https://learn.javascript.ru/fetch#:~:text=%D0%92%D0%BE%2D%D0%B2%D1%82%D0%BE%D1%80%D1%8B%D1%85%2C%20%D0%B4%D0%BB%D1%8F%20%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%82%D0%B5%D0%BB%D0%B0%20%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0%20%D0%BD%D0%B0%D0%BC%20%D0%BD%D1%83%D0%B6%D0%BD%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0.).
После чего нужно вытащить из ответа только нужные нам поля, чтобы не перегружать память ненужной информацией - посмотрите сначала через инструменты разработчика, что приходит от сервиса и напишите (положите в helpers) функцию которая будет преобразовывать (мапить - отсюда все такие функции начинаются с map (в них и метод массива этот используется)) чистый формат ответа - DTO в нужный для наших целей тип.

